package beastmap.tools;


import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import beast.base.core.Description;
import beast.base.core.Input;
import beast.base.core.Log;
import beast.base.evolution.tree.Node;
import beast.base.evolution.tree.Tree;
import beast.base.evolution.tree.TreeUtils;
import beast.base.inference.Runnable;
import beast.base.util.DiscreteStatistics;
import beast.base.util.HeapSort;
import beastfx.app.tools.Application;
import beastfx.app.util.OutFile;
import beastfx.app.util.TreeFile;
import beastmap.tools.utils.MemoryFriendlyTreeSet;
import beastmap.tools.utils.TreeFileParser;

@Description("Annotates state typing onto a summary tree")
public class SegmentedTreeAnnotator extends Runnable {

	String[] heightSummaryOptions = new String[] { "mean", "median", "uniform" };
	
	final public Input<TreeFile> summaryTreeInput = new Input<>("tree", "the summary tree", Input.Validate.REQUIRED);
	final public Input<TreeFile> typeTreesInput = new Input<>("segments","the typed trees that described states (generated by beastmap.logger.TypedTreeLogger)", Input.Validate.REQUIRED);
	final public Input<OutFile> outputInput = new Input<>("out", "output file, or stdout if not specified", Input.Validate.REQUIRED);
	final public Input<Integer> burnInPercentageInput = new Input<>("burnin", "percentage of trees to used as burn-in (and will be ignored)", 10);
	final public Input<Boolean> verboseInput = new Input<>("verbose", "print information about clades of interest, and if no output file is specified, all clade information", true);
	final public Input<String> typeLabelInput = new Input<>("typeLabel", "the name of the branch metadata variable that stores the state", "state");
	
	
	final public Input<String> heightInput = new Input<>("height", "method for summarising segment heights", "mean", heightSummaryOptions);
	
	
	int negativeSegmentCount = 0;
	String typeLabel;
	Tree summaryTree;
	
	@Override
	public void initAndValidate() {
		
		
		
		// TEST
		
//		try {
//		for (int i = 0; i < 1e10; i ++){
//			beastfx.app.treeannotator.TreeAnnotator.MemoryFriendlyTreeSet stateTrees = ta.new MemoryFriendlyTreeSet(summaryTreeInput.get().getAbsolutePath(), 10);
//			//stateTrees.setAllowUnaryNodes(true);
//			stateTrees.reset();
//			Log.warning("i=" + i);
//			while (stateTrees.hasNext()) {
//				Tree tree = stateTrees.next();
//				
//			}
//		}
//		
//		} catch (Exception e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		
		
		this.typeLabel = typeLabelInput.get();
		
		// Load the summary tree
		try {
			TreeFileParser parser = new TreeFileParser(summaryTreeInput.get().getAbsolutePath(), 0); 
			Tree[] trees = parser.parseFile();
			if (trees.length != 1) {
				throw new IllegalArgumentException("Please ensure the summary tree file contains just one tree");
			}
			summaryTree = trees[0];
		} catch (Exception e) {
			e.printStackTrace();
			throw new IllegalArgumentException("Error parsing the summary tree at " + typeTreesInput.get().getAbsolutePath());
		}
		
		
		// Load the state trees
		try {
			
			MemoryFriendlyTreeSet stateTrees = new MemoryFriendlyTreeSet(typeTreesInput.get().getAbsolutePath(), burnInPercentageInput.get());
			stateTrees.setAllowUnaryNodes(true);
			stateTrees.reset();
		
			// Ensure the two have the same taxa
			String[] taxa = summaryTree.getTaxaNames();
			Arrays.sort(taxa);
			
			
			Tree tree = stateTrees.next(); 
			String[] taxa2 = tree.getTaxaNames();
			Arrays.sort(taxa2);
			
			if (taxa.length != taxa2.length) {
				throw new IllegalArgumentException("Inconsistent taxon count " + taxa.length + "!=" + taxa2.length);
			}
			
			for (int i = 0; i < taxa.length; i ++) {
				String t1 = taxa[i];
				String t2 = taxa2[i];
				if (!t1.equals(t2)) {
					throw new IllegalArgumentException("Unknown taxon found in state trees " + t2 + ". Please ensure both tree files contain the same taxa. " + t1);
				}
			}
				
				
		} catch (IOException e) {
			e.printStackTrace();
			throw new IllegalArgumentException("Error parsing one of the state trees at " + typeTreesInput.get().getAbsolutePath());
		}
		
		
		

		
	}

	@Override
	public void run() throws Exception {
		
		
		
		negativeSegmentCount = 0;
		
		// Convert the tree into a tree where each node has a difference sequence, according to the posterior distribution
		Node root = summaryTree.getRoot();
		List<Node> nodes = root.getAllChildNodesAndSelf();
		
		
		List<List<BranchTrajectory>> trajectoriesAll = new ArrayList<>();
		for (int i = 0; i < nodes.size(); i ++) {
			List<BranchTrajectory> trajectories = new ArrayList<>();
			trajectoriesAll.add(trajectories);
		}
		
		
		
		// Summarise the branch above this node
		MemoryFriendlyTreeSet stateTrees = new MemoryFriendlyTreeSet(typeTreesInput.get().getAbsolutePath(), burnInPercentageInput.get());
		stateTrees.setAllowUnaryNodes(true);
		stateTrees.reset();
		
		//int treeNum = 0;
		while (stateTrees.hasNext()) {
			
			//Log.warning(i + ", " + treeNum);
			//treeNum++;
			
			Tree stateTree = stateTrees.next();
		
			
			for (int i = 0; i < nodes.size(); i ++) {
				
				
				Node node = nodes.get(i);
				if (node.isRoot()) continue;
				
				BranchTrajectory traj = getTrajectory(node, stateTree);
				if (traj == null) continue;
				trajectoriesAll.get(i).add(traj);
				
				//Log.warning("Adding " + traj + " to " + node.getNr());
				
				
				
				// Most probable state for parent and child
//				String mostProbableParent = this.getMostCommon(parentStateCount);
//				String mostProbableChild = this.getMostCommon(childStateCount);
//				double parentProb = this.getProb(mostProbableParent, parentStateCount);
//				double childProb = this.getProb(mostProbableChild, childStateCount);
//				
//				Log.warning("\tThe most probable child is " + mostProbableChild + " wp "+ childProb);
//				Log.warning("\tThe most probable parent is " + mostProbableParent + " wp "+ parentProb);
				
				
			}		
					
			
		}
		
		
		int k = nodes.size();
		for (int i = 0; i < nodes.size(); i ++) {
			Node node = nodes.get(i);
			List<BranchTrajectory> trajectories = trajectoriesAll.get(i);
			
			if (trajectories.isEmpty()) {
				//throw new IllegalArgumentException("Cannot find clade " + node.getNr() + " in segmented tree file. Please ensure the summary tree file and segmented tree files are sampling the same disrtribution. Perhaps the MCMC chain needs to be run for longer.");
				Log.warning("Warning: cannot find clade " + node.getNr() + " in segmented tree file. Please ensure the summary tree file and segmented tree files are sampling the same disrtribution. Perhaps the MCMC chain needs to be run for longer.");
				continue;
			}
			
			
			k = this.addSegments(node, trajectories, k);
			//Log.warning("Successfully mapped node " + node.getNr());
		}
		
		
		Log.warning("Finished!");
		
		if (negativeSegmentCount > 0) {
			Log.warning("");
			Log.warning("Warning: " + negativeSegmentCount + " negative segments detected. "
					+ "Running the MCMC chain for longer might fix this issue. "
					+ "In the worse case scenario, you can evenly stagger all segement heights on the summary tree by setting height to 'uniform' rather than 'mean' or 'median'. "
					+ "Note that the posterior summary of segment heights will still be recorded.");
			Log.warning("");
		}else {
			Log.warning("");
			Log.warning("No negative segments detected.");
			Log.warning("");
		}
		
		
		// Save file
		//processMetaData(root);
		PrintStream out = new PrintStream(outputInput.get());
		summaryTree.init(out);
		out.println();
		//out.println("tree STATE_TREE = " + root.toShortNewick(true) + ";");
		int[] dummy = new int[1];
        String newick = root.toSortedNewick(dummy, true);
        out.println("tree STATE_TREE = " + newick + ";");
		summaryTree.close(out);
		Log.warning("Saved state tree to " + outputInput.get().getPath());
		
		
	}
	
	private BranchTrajectory getTrajectory(Node node, Tree stateTree) throws IOException{
		
		
		// Parent state
		HashMap<String,Integer> parentStateCount = new HashMap<>();
		HashMap<String,Integer> childStateCount = new HashMap<>();
		
	
		// Clade
		Set<String> cladeSet = new HashSet<>();
		if (node.isLeaf()) cladeSet.add(node.getID());
		else for (Node leaf : node.getAllLeafNodes()) {
			cladeSet.add(leaf.getID());
		}
			
	
		
		
		// Summarise the branch above this node
		BranchTrajectory traj = new BranchTrajectory(node.getNr());
		
		
		// Find this clade in the posterior
		Node stateNode = null;
		if (node.isLeaf()) {
			for (Node leaf : stateTree.getRoot().getAllLeafNodes()) {
				if (leaf.getID().equals(node.getID())) {
					stateNode = leaf;
					break;
				}
			}
		}else {
			stateNode = TreeUtils.getCommonAncestorNode(stateTree, cladeSet);
			
			
			// It is monophyletic?
			Set<String> leaves = TreeUtils.getDescendantLeaves(stateTree, stateNode);
			if (leaves.size() != cladeSet.size()) {
				//Log.warning(leaves.size() + " != " + cladeSet.size());
				return null;
			}
			
			
		}
		
		
		if (stateNode.isRoot()) {
			return null;
		}
		
		// Record option of parent and child states
		String childState = getStateOfNode(stateNode);
		this.incrementCount(childStateCount, childState);
	
		// Repeat until we have reached the top of this lineage
		do{
			
			String stateOfNode = getStateOfNode(stateNode); 
			double h2 = stateNode.getHeight();
			double h1 = stateNode.isRoot() ? h2 : stateNode.getParent().getHeight();
			BranchState branchState = new BranchState(stateOfNode, h1, h2);
			traj.add(branchState);
			
			stateNode = stateNode.getParent();
			
			
		}while(stateNode != null && stateNode.getChildCount() != 2);
		
	
		String parentState = getStateOfNode(stateNode);
		this.incrementCount(parentStateCount, parentState);
		return traj;
		
	}

		
	private int addSegments(Node node,  List<BranchTrajectory> trajectories, int k) throws IOException{
	


		
		// What is the most probable mutation pathway
		HashMap<String,Integer> pathwayCount = new HashMap<>();
		for (BranchTrajectory trajectory : trajectories) {
			String p = trajectory.getOldestState().getState();
			String c = trajectory.getYoungestState().getState();
//			if (p.equals(mostProbableParent) && c.equals(mostProbableChild)) {
//				String path = trajectory.getPath();
//				this.incrementCount(pathwayCount, path);
//			}
			
			String path = trajectory.getPath();
			this.incrementCount(pathwayCount, path);
			
		}
		
		if (pathwayCount.isEmpty()) {
			throw new IllegalArgumentException("Cannot find clade and pathway in segmented tree file. Please ensure the summary tree file and segmented tree files are sampling the same disrtribution. Perhaps the MCMC chain needs to be run for longer.");
		}
		
		
		String mostProbablePath = this.getMostCommon(pathwayCount);
		int maxCount = pathwayCount.get(mostProbablePath);
		double pathP = 1.0 * maxCount / trajectories.size();
		Log.warning("\tThe most probable path is " + mostProbablePath.replaceAll("&",  " <- ") + " wp " + pathP);
		
		
		
		// Have one lineage per state in the path along this branch
		String[] steps = mostProbablePath.split("&");
		
		
	
		double h2Node = node.getHeight();
		double h1Node = node.getParent().getHeight();
		for (int stepNr = 0; stepNr < steps.length-1; stepNr ++) {
			
			
			String state = steps[stepNr];
			
			// Insert a new segment 
			Node younger = new Node();
			
			// Give it the right name
			if (node.isLeaf()) {
				younger.setID(node.getID());
				younger.setNr(node.getNr());
				node.setNr(k);
				k++;
			}
			
			for (Node child : node.getChildren()) {
				younger.addChild(child);
			}
			node.removeAllChildren(true);
			node.addChild(younger);
			
			
			// Set state of younger segment
			younger.setMetaData(typeLabel, state);
			younger.setMetaData(typeLabel + ".path.prob", pathP);
			younger.metaDataString = node.metaDataString + "," + typeLabel + "='" + state + "'," + typeLabel + ".path.prob=" + pathP;
			younger.setHeight(node.getHeight());
			
//			if (stepNr == 0) {
//				younger.metaDataString += "," + typeLabel + ".prob=" + childProb;
//			}
			
			
	//				// Set height of older segment
			double[] heightsArr = new double[maxCount];
			int m = 0;
			for (BranchTrajectory trajectory : trajectories) {
				if (trajectory.getPath().equals(mostProbablePath)) {
					double h2 = trajectory.getChildHeight(stepNr);
					double h1 = trajectory.getParentHeight(stepNr);
					heightsArr[m] = h1;
					//heightsArr[k] = node.getHeight() + (h1Node - node.getHeight()) / (steps.length) * (stepNr+1); // HACK TO FIX
					m++;
					
				}
			}
			
			
			
			if (m != maxCount) {
				Log.warning("dev error: 0822s " + m + "!=" + maxCount);			
			}
			
			
			// None of these solutions are satisfying. The first two can give negative branch lengths. 
			// Uniform will not give negative branch lengths, but it is just a hack for making a pretty tree. not properly model based
			double pseudoHeight = 0;
			switch(heightInput.get()) {
			case "median":{
				pseudoHeight = DiscreteStatistics.median(heightsArr);
				break;
			}
			case "mean":{
				pseudoHeight = DiscreteStatistics.mean(heightsArr);
				break;
			}
	
			case "uniform":{ 
				pseudoHeight = node.getHeight() + (h1Node - node.getHeight()) / (steps.length) * (stepNr+1);
				break;
			}
			
			}
			
			
			Log.warning("\tSetting height to " + pseudoHeight + " for " + stepNr + " " + node.getHeight() + "/" + h1Node);
			if (pseudoHeight > node.getParent().getHeight() || pseudoHeight < younger.getHeight()) {
				negativeSegmentCount++;
			}
			
			
			node.setHeight(pseudoHeight);
			
			// No more metadata for the parent segments
			double[] hpd = getHPD(0.95, heightsArr);
			String attributeName = "segment.height";
			node.metaDataString = "";
			node.metaDataString += "is_segment=true,";
			node.metaDataString += attributeName + "_mean=" + DiscreteStatistics.mean(heightsArr) + ",";
			node.metaDataString += attributeName + "_median=" + DiscreteStatistics.median(heightsArr) + ",";
			node.metaDataString += attributeName + "_95%_HPD={" + hpd[0] + "," + hpd[1] + "}";
			
		}	
		
		
		// Set state of top segment
		String state = steps[steps.length-1];
		node.setMetaData(typeLabel, state);
		node.setMetaData(typeLabel + ".path.prob", pathP);
		String delim = node.metaDataString.isEmpty() ? "" : ",";
		node.metaDataString += delim + typeLabel + "='" + state + "'," + typeLabel + ".path.prob=" + pathP;
		
		
		return k;
		
	}
	
	
	
	
	
	
	private double getProb(String key, HashMap<String, Integer> map) {
		int count = 0;
		for (String path : map.keySet()) {
			count += map.get(path);
		}
		return 1.0 * map.get(key) / count;
	}

	private double[] getHPD(double hpd, double[] values) {
        int[] indices = new int[values.length];
        HeapSort.sort(values, indices);

        double minRange = Double.MAX_VALUE;
        int hpdIndex = 0;

        int diff = (int) Math.round(hpd * values.length);
        for (int i = 0; i <= (values.length - diff); i++) {
            double minValue = values[indices[i]];
            double maxValue = values[indices[i + diff - 1]];
            double range = Math.abs(maxValue - minValue);
            if (range < minRange) {
                minRange = range;
                hpdIndex = i;
            }
        }
        double lower = values[indices[hpdIndex]];
        double upper = values[indices[hpdIndex + diff - 1]];
        return new double[] {lower, upper};
    }
	
	private void incrementCount(HashMap<String,Integer> map, String key) {
		if (map.containsKey(key)) {
			map.put(key, map.get(key) + 1);
		}else {
			map.put(key, 1);
		}
	}
	
	private String getMostCommon(HashMap<String, Integer> map) {
		
		String mostProbable = "";
		int maxCount = 0;
		for (String path : map.keySet()) {
			int count = map.get(path);
			if (count > maxCount) {
				mostProbable = path;
				maxCount = count;
			}
		}
		return mostProbable;
	}
	
//	
//	private void processMetaData(Node node) {
//		for (Node child : node.getChildren()) {
//			processMetaData(child);
//		}
//		Set<String> metaDataNames = node.getMetaDataNames(); 
//		if (metaDataNames != null && !metaDataNames.isEmpty()) {
//			String metadata = "";
//			for (String name : metaDataNames) {
//				Object value = node.getMetaData(name);
//				metadata += name + "=";
//				if (value instanceof Object[]) {
//					Object [] values = (Object[]) value;
//					metadata += "{";
//					for (int i = 0; i < values.length; i++) {
//						metadata += values[i].toString();
//						if (i < values.length - 1) {
//							metadata += ",";
//						}
//					}
//					metadata += "}";
//				} else {
//					 metadata += value.toString();
//				}
//				metadata += ",";
//			}
//			metadata = metadata.substring(0, metadata.length() - 1);
//			node.metaDataString = metadata;
//		}		
//	}

	
	
	private String getStateOfNode(Node node) {
		String metaDataString = node.metaDataString;
		String[] bits = metaDataString.split(this.typeLabel + "=");
		
		if (bits.length != 2) {
			throw new IllegalArgumentException("Error extracting " + this.typeLabel + " from tree");
		}
		
		//Log.warning(bits[0] + " and " + bits[1]);
		String state = bits[1];
		state = state.replaceAll("'", "");
		state = state.replaceAll("\"", "");
		state = state.replaceAll(",*+", "");
		
		return state;
	}
	
	
	private class BranchTrajectory {
		
		
		List<BranchState> states;
		int nodeNr;
		
		public BranchTrajectory(int nodeNr) {
			this.nodeNr = nodeNr;
			this.states = new ArrayList<>();
		}
		
		public double getParentHeight(int stepNr) {
			return this.states.get(stepNr).getParentHeight();
		}
		
		public double getChildHeight(int stepNr) {
			return this.states.get(stepNr).getChildHeight();
		}

		public void add(BranchState state) {
			this.states.add(state);
		}
		
		public List<BranchState> getStates() {
			return this.states;
		}
		
		public int getNStates() {
			return this.states.size();
		}
		
		public BranchState getOldestState() {
			return this.states.get(this.states.size()-1);
		}
		
		public BranchState getYoungestState() {
			return this.states.get(0);
		}
		
		public String getPath() {
			
			String path = "";
			for (int i = 0; i < this.getNStates();  i++) {
				path += this.states.get(i).getState();
				if (i < this.getNStates()-1) {
					path += "&";
				}
			}
			
			return path;
		}
		
		
	}
	
	private class BranchState {
		
		String state;
		double h1; // Parent age
		double h2; // Child age
		
		public BranchState(String state, double h1, double h2) {
			this.state = state;
			this.h1 = h1;
			this.h2 = h2;
		}
		
		public double getParentHeight() {
			return this.h1;
		}
		
		public double getChildHeight() {
			return this.h2;
		}
		
		public String getState() {
			return this.state;
		}
		
		
	}

	

	public static void main(String[] args) throws Exception {
		new Application(new SegmentedTreeAnnotator(), "Segmented Tree Annotator", args);

	}
	
	
	

}



